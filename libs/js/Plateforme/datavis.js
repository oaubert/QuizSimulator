/**
 * Constructor of the DataVis class
 *
 * @class     <Datavis> This class is here to provide a visualisation of the data generated by the simulator
 * @param      {String}  container  The container where we place the visualization
 */
TestsCoco.DataVis = function(container) {
        this.container = container;
};

/**
 * Sorts and complete an object with the right properties
 *
 * @method     sortAndComplete
 * @param      {Object}  tab     The initial object
 * @return     {Object}  The completed and ordered object
 */
TestsCoco.DataVis.prototype.sortAndComplete = function (tab) {
    var order = ['right_answer', 'wrong_answer', 'skipped_answer', 'useful', 'useless', 'skipped_vote'];
    return _.mapValues(tab, function(value) {
        var obj = {};
        order.forEach(function(elem) {
            if (value !== undefined) {
                obj[elem] = (value[elem]===undefined) ? 0 : value[elem];
            } else {
                obj[elem] = 0;
            }
        });
        return obj;
    });
};

/**
 * Get the session dates of objects in <tt>tab</tt>
 *
 * @method     getSessionDate
 * @param      {Object}  tab
 * @return     {Object}  The session dates
 */
TestsCoco.DataVis.prototype.getSessionDate = function(tab) {
    var group = _.groupBy(tab, 'session');
    return _.mapValues(group, function(value) {
        return new Date(_.first(value).date);
    });
};

/**
 * Count the properties (<tt>key2</tt>) in data of <tt>tab</tt> grouped by <tt>key1</tt>
 *
 * @method     getPropertiesByKey
 * @param      {Object}  tab     Initial object
 * @param      {string}  key     First key for grouping data
 * @param      {string}  key2    Second key for counting
 * @return     {Object}
 */
TestsCoco.DataVis.prototype.getPropertiesByKey = function(tab, key, key2) {
    var group = _.groupBy(tab, key);
    return _.mapValues(group, function(value) {
        return _.countBy(value, key2);
    });
};

/**
 * Count the properties (<tt>key3</tt>) in data of <tt>tab</tt> grouped first by <tt>key2</tt> and by <tt>key2</tt>
 *
 * @method     aggregate
 * @param      {Object}  tab     Initial object
 * @param      {string}  key1    First key for grouping
 * @param      {string}  key2    Second key for grouping
 * @param      {string}  key3    Third key for counting
 * @return     {Object}
 */
TestsCoco.DataVis.prototype.aggregate = function(tab, key1, key2, key3) {
    var group = _.groupBy(tab, key1);

    var groupByKey2 = _.mapValues(group,function(value){
        return _.groupBy(value,key2);
    });

    return _.mapValues(groupByKey2, function(value) {
        return _.mapValues(value, function(value2) {
            return _.countBy(value2, key3);
        });
    });
};

/**
 * Get the number of answers by questions
 *
 * @method     getNbAnswerByQuestion
 * @param      {Object}  tab     Dataset of answers
 * @return     {Object}  Object with first key, the question id, and second key, the answer property. The values are the number of each property.
 */
TestsCoco.DataVis.prototype.getNbAnswerByQuestion = function(tab){
    var obj = {};
    var valueByPropertyByQuestion = this.aggregate(tab, 'subject', 'property', 'value');
    _.each(valueByPropertyByQuestion, function(value, index) {
        obj[index] = {};
        _.each(value, function(value2, index2) {
            if(index2.match(/right_answer|wrong_answer/gi) != null) {
                _.each(value2, function(value3, index3) {
                    obj[index][index3]=value3;
                });
            }
        });
    });
    return obj;
};

/**
 * Get the informations needed for each questions, in order to display them.
 *
 * @method     getInfoQuestions
 * @param      {Array}  annotations  Set of annotations
 * @return     {Object}  Informations about each questions
 */
TestsCoco.DataVis.prototype.getInfoQuestions = function(annotations) {
    var ret = {};

    _.each(annotations, function(value, index) {
        if(value.type === 'Quiz' || value.type_title === 'Quiz') {
            var q_id = value.id;
            var desc = value.content.data.question;
            var ans = value.content.data.answers;
            var time = value.begin;
            var correct =[];
            var content=[];
            _.each(ans, function(ans_value, ans_index) {
                content.push(ans_value.content);
                correct.push(ans_value.correct);
            });
            ret[q_id]={};
            ret[q_id]['enonce']=desc;
            ret[q_id]['answers']=content;
            ret[q_id]['correct']=correct;
            ret[q_id]['time']=time;
        }
    });

    return ret;
};

/**
 * Get the percentages of values of properties of an object
 *
 * @method     getPercentages
 * @param      {Object}  obj     Initial object
 * @return     {Object}  Object with percentages
 */
TestsCoco.DataVis.prototype.getPercentages = function(obj) {
    obj.all_answer=(obj.right_answer+obj.wrong_answer);
    obj.all_answer_and_skipped=(obj.right_answer+obj.wrong_answer+obj.skipped_answer);

    obj.all_utility_answer=(obj.usefull + obj.useless);
    obj.all_utility_answer_and_skipped=(obj.usefull + obj.useless + obj.skipped_vote);

    obj.right_answer = obj.right_answer * 100 / (obj.all_answer);
    obj.wrong_answer = obj.wrong_answer * 100 / (obj.all_answer);
    obj.skipped_answer = obj.skipped_answer * 100 / (obj.all_answer_and_skipped);

    obj.useful = obj.useful * 100 / (obj.all_utility_answer);
    obj.useless = obj.useless * 100 / (obj.all_utility_answer);
    obj.skipped_vote = obj.skipped_vote * 100 / (obj.all_utility_answer_and_skipped);

    return obj;
};

/**
 * Calculate the least squares of two series
 *
 * @method     leastSquares
 * @param      {Array}  xSeries  The first series
 * @param      {Array}  ySeries  The second series
 * @return     {Array}   Array that contains : slope, intercept ans rSquare of the least squares
 */
TestsCoco.DataVis.prototype.leastSquares = function (xSeries, ySeries) {
    var reduceSumFunc = function(prev, cur) { return prev + cur; };

    if (! xSeries.length || ! ySeries.length) {
        return [0, 0, 0];
    }
    var xBar = xSeries.reduce(reduceSumFunc) * 1.0 / xSeries.length;
    var yBar = ySeries.reduce(reduceSumFunc) * 1.0 / ySeries.length;

    var ssXX = xSeries.map(function(d) { return Math.pow(d - xBar, 2); })
        .reduce(reduceSumFunc);

    var ssYY = ySeries.map(function(d) { return Math.pow(d - yBar, 2); })
        .reduce(reduceSumFunc);

    var ssXY = xSeries.map(function(d, i) { return (d - xBar) * (ySeries[i] - yBar); })
        .reduce(reduceSumFunc);

    var slope = ssXY / ssXX;
    var intercept = yBar - (xBar * slope);
    var rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);

    return [slope, intercept, rSquare];
};

/**
 * Constructs a RegExp
 *
 * @method     makeRegExp
 * @param      {Array}  tab     Elements of the RegExp
 * @return     {RegExp}  The RegExp generated
 */
TestsCoco.DataVis.prototype.makeRegExp = function (tab) {
    return new RegExp(tab.join("|"), 'gi');
};

/**
 * Make the french traduction of the label for the answers
 *
 * @method     modifyLabel
 * @param      {string}  str     Initial label
 * @return     {string}  Modified label
 */
TestsCoco.DataVis.prototype.modifyLabel = function(str) {
    var label = {
        right_answer: 'Bonnes',
        wrong_answer: 'Mauvaises',
        skipped_answer: 'Passées',
        useful: 'Utiles',
        useless: 'Inutiles',
        skipped_vote: 'Passés'
    };
    return label[str];
};

/**
 * Associate a color to a label.
 *
 * @method     getColor
 * @param      {strinf}  str     The label
 * @param      {string}  type    Type of category
 * @return     {string}  Color code
 */
TestsCoco.DataVis.prototype.getColor = function(str, type) {
    var colors = {
        'user': {
            right_answer: '#6B8E23',
            wrong_answer: '#B22222',
            skipped_answer: 'gray',
            useful: '#6B8E23',
            useless: '#B22222',
            skipped_vote: 'gray'
        },
        'default': {
            'right_answer': 'green',
            'wrong_answer': 'red',
            'skipped_answer': '#C0C0C0',
            'useful': 'green',
            'useless': 'red',
            'skipped_vote': '#C0C0C0'
        }
    };
    return colors[type || 'default'][str];
};

/**
 * Combine data of an object into an array of objects
 *
 * @method     combine
 * @param      {Object}  tab     Initial object
 * @return     {Array}   Array of objects
 */
TestsCoco.DataVis.prototype.combine = function(tab) {
    return _.map(tab, function (elem, index) {
        return {
            key: index,
            value: elem[0].values
        };
    });
};

/**
 * Get the user uuids
 *
 * @method     getUsers
 * @param      {Object}  answers  Set of answers
 * @return     {Array}  The user uuids
 */
TestsCoco.DataVis.prototype.getUsers = function(answers) {
    return _.keys(_.groupBy(answers, 'useruuid'));
};

/**
 * Get the session ids by user
 *
 * @method     getSessionByUser
 * @param      {Object}  answers  Set of answers
 * @return     {Object}  Keys are the user uuids and values, arrays of session id
 */
TestsCoco.DataVis.prototype.getSessionByUser = function(answers) {
    return _.mapValues(_.groupBy(answers, 'useruuid'), function(val) {
                return _.keys(_.groupBy(val, 'session'));
    });
};

/**
 * Get the media of one question
 *
 * @method     getMedia
 * @param      {Object}  medias   Set of medias
 * @param      {string}  subject  Question id
 * @return     {string}  Media id
 */
TestsCoco.DataVis.prototype.getMedia = function(medias, subject) {
    var med = _.mapValues(medias, function(val) {
            return _.filter(val, function(v) {
                return v.id == subject;
            });
        });

    return _.findKey(med, function(v) {
        return v.length != 0;
    });
};

/**
 * Get the average score by user
 *
 * @method     getUsersAverage
 * @param      {Object}  prop      Properties of each question
 * @param      {Object}  sessions  Properties of each session
 * @return     {Object}  Score by user
 */
TestsCoco.DataVis.prototype.getUsersAverage = function(prop, sessions) {
    var _this = this;
    var ret = {};
    _.each(prop, function(value, index) {
        ret[index]={};
        _.each(value, function(s_val, s_idx) {
            var med = _.findKey(sessions, function(s) {return _.includes(s, s_idx);});
            ret[index][med] = ret[index][med] ? ret[index][med] : [];
            var right = s_val.right_answer ? s_val.right_answer : 0;
            var wrong = s_val.wrong_answer ? s_val.wrong_answer : 0;
            ret[index][med].push(right * 100 / (right + wrong));
        });
    });
    return _.mapValues(ret, function(media) {
            return _.mapValues(media, function(notes) { return notes.length ? _.sum(notes) / notes.length : 0; });
    });
};

/**
 * Get the average score for each media
 *
 * @method     getGeneralAverage
 * @param      {Object}  medias  Set of medias
 * @return     {Object}  Average score by media
 */
TestsCoco.DataVis.prototype.getGeneralAverage = function(medias) {
    var _this = this;
    var ret = {};
    var averages = this.getUsersAverage(this.propertiesBySessionByUser, this.sessionByMedia);
    var n = _.size(averages);
    var videos = _.keys(medias);
    videos.forEach(function(video) {
        ret[video]=0;
        _.each(averages, function(value, index) {
            ret[video] += value[video];
        });
        ret[video] = ret[video]/n;
    });
    return ret;
};

/**
 * Get information for each media
 *
 * @method     getMediaInfo
 * @param      {string}  media_id
 * @return     {Object}  Informations about the media
 */
TestsCoco.DataVis.prototype.getMediaInfo = function(media_id){
    var begin_times = _.pluck(_.filter(_.values(this.medias[media_id]), 'type', 'Quiz'), 'begin');
    var end_times = _.pluck(_.filter(_.values(this.medias[media_id]), 'type', 'Quiz'), 'end');
    var max_time = _.max(end_times);
    return {'times': begin_times, 'max_time': max_time};
};

/**
 * Get the answers properties of each question of each media
 *
 * @method     getPropertiesByQuestionByMedia
 * @return     {Object}  Properties by question by media
 */
TestsCoco.DataVis.prototype.getPropertiesByQuestionByMedia = function() {
    var _this = this;

    var questionByMedia = _.mapValues(this.medias, function(value) {
        return _.keys(_.groupBy(value, 'id'));
    });

    var mapped = _.mapValues(questionByMedia, function(value) {
        return _.mapKeys(value, function(val, key) {
            return val;
        });
    });

    return _.mapValues(mapped, function(value) {
        return _.mapValues(value, function(val) {
            return _this.propertiesByQuestion[val];
        });
    });
};

/**
 * Get all the answers properties by medias
 *
 * @method     getPropertiesByMedia
 * @return     {Object}  Properties by media
 */
TestsCoco.DataVis.prototype.getPropertiesByMedia = function(){
    return _.mapValues(this.getPropertiesByQuestionByMedia(),function(value){
            var right = 0,
                wrong = 0,
                skip_a = 0,
                useful = 0,
                useless = 0,
                skip_v = 0;
            _.each(value, function(q_value, q_index) {
                if(q_value !== undefined) {
                    right += q_value.right_answer ? q_value.right_answer : 0;
                    wrong += q_value.wrong_answer ? q_value.wrong_answer : 0;
                    skip_a += q_value.skipped_answer ? q_value.skipped_answer : 0;
                    useful += q_value.useful ? q_value.useful : 0;
                    useless += q_value.useless ? q_value.useless : 0;
                    skip_v += q_value.skipped_vote ? q_value.skipped_vote : 0;
                } else {
                    right += 0,
                    wrong += 0,
                    skip_a += 0,
                    useful += 0,
                    useless += 0,
                    skip_v += 0;
                }
            });
            return {
                'right_answer': right,
                'wrong_answer': wrong,
                'skipped_answer': skip_a,
                'useful': useful,
                'useless': useless,
                'skipped_vote': skip_v
            };
        });
};

/**
 * Get the media id for each sessions
 *
 * @method     getMediaBySession
 * @return     {Object}  Medias by session
 */
TestsCoco.DataVis.prototype.getMediaBySession = function() {

    var sub_bySession = _.mapValues(this.sessions,function(value) {
        return value[0].subject;
    });

    var q_byMed = _.mapValues(this.getPropertiesByQuestionByMedia(), function(val) {
        return _.keys(val);
    });

    return _.mapValues(sub_bySession, function(value) {
        var ret;
        _.each(q_byMed, function(val, idx) {
            if(_.indexOf(value, val) != -1) {
                ret = idx;
            }
        });
        return ret;
    });
};

/**
 * Get the sessions ids for each medias
 *
 * @method     getSessionByMedia
 * @return     {Object}  Sessions by media
 */
TestsCoco.DataVis.prototype.getSessionByMedia = function() {
    var questionByMedia = _.mapValues(this.medias, function(value) {
        return _.keys(_.groupBy(value, 'id'));
    });

    var questionBySession = _.mapValues(this.sessions, function(val) {
        return _.keys(_.groupBy(val, 'subject'));
    });

    return _.mapValues(questionByMedia, function(value) {
        var ret=[];
        value.forEach(function(q_val) {
            _.each(questionBySession, function(val, idx) {
                if(_.indexOf(q_val, val) != -1) {
                    ret.push(idx);
                }
            });
        });
        return _.uniq(ret);
    });

};

/*
 * Histograms
 *
 */

TestsCoco.DataVis.prototype.dataForHisto = function(wantedData, tab_total, tab_user, tab_media) {
    var _this = this;
    var ret = {};
    var sorted_total_data = _.mapValues(this.sortAndComplete(tab_total), function(val) {
        return _this.getPercentages(val);
    });
    _.each(tab_user, function(value, index) {
        ret[index]=[];
        var sorted_session_data = _.mapValues(_this.sortAndComplete(value), function(val) {
            return _this.getPercentages(val);
        });
        _.each(sorted_session_data, function(s_value, s_index) {
            var data = {};
            data['key']=s_index;
            data['values']=[];
            _.each(s_value, function(prop_value, prop_index) {
                if(prop_index.match(_this.makeRegExp(wantedData)) != null) {
                    var prop = {};
                    var val;
                    prop['label']=_this.modifyLabel(prop_index);
                    prop['value']=prop_value;
                    prop['color']='blue';
                    data['values'].push(prop);
                }
            });
            var total_data = sorted_total_data[tab_media[s_index]];
            _.each(total_data, function(value2, index2) {
                if(index2.match(_this.makeRegExp(wantedData)) != null) {
                    var prop = {};
                    prop['label']='Total '+_this.modifyLabel(index2);
                    prop['value']=value2;
                    prop['color']='green';
                    data['values'].push(prop);
                }
            });

            ret[index].push([data]);
        });
    });

    return ret;
};

TestsCoco.DataVis.prototype.dataForHisto_AnsVote = function(wantedData, tab_total, tab_user, tab_media) {
    var _this = this;
    var sorted_total_data = _.mapValues(this.sortAndComplete(tab_total), function(val) {
        return _this.getPercentages(val);
    });

    function get_data(key, tab, category) {
        return {
                'key' : key,
                'values' : _.map(tab, function(prop_value, prop_index) {
                                        return{
                                            'x' : _this.modifyLabel(prop_index),
                                            'y' : prop_value,
                                            'index' : prop_index,
                                            'color' : _this.getColor(prop_index, category)
                                        };
                                    }).filter(function(s) { return _.includes(wantedData, s.index); } )
            };
    };

    return _.mapValues(tab_user, function(user) {
        var sorted_session_data = _.mapValues(_this.sortAndComplete(user), function(val) {
            return _this.getPercentages(val);
        });
        return _.mapValues(sorted_session_data, function(s_value, s_index) {
            var total_data = sorted_total_data[tab_media[s_index]];
            return [get_data('Sur la session (étudiant seul)', s_value, 'user'), get_data('Totale (tous les étudiants)', total_data, 'total')];
        });
    });
};

TestsCoco.DataVis.prototype.dataForHisto_AnswerDetail = function(tab, info_questions) {
    return _.mapValues(tab, function(q_val, q_idx) {
        var values = [];
        if (info_questions[q_idx] !== undefined) {
            var nb_ans = info_questions[q_idx].answers.length;
            var correct = info_questions[q_idx].correct;
            for(var i = 0 ; i < nb_ans ; i++) {
                values.push({
                    'label' : (i+1),
                    'value' : (q_val[i] != undefined) ? q_val[i] : 0,
                    'color' : correct[i] ? 'green' : 'grey'
                });
            }
        } else {
            // No more existing question. Produce a 1-answer pseudo question
            values = [ { 'label': 1,
                         'value': 0,
                         'color': 'green' } ];
        }
        return [{
            'key' : q_idx,
            'values' : values
        }];
    });
};

TestsCoco.DataVis.prototype.makeHistogram_AnsVote = function (data, container, title) {
    if(document.getElementById(container) === null) {
        $(this.container).append('<div id='+container+'><svg></svg></div>');
    }
    var selector = '#'+container+' svg';

    nv.addGraph(function() {
        var chart = nv.models.multiBarChart()
                    .yDomain([0, 100])
                    .showControls(false)
                    .showLegend(false);

            chart.yAxis.axisLabel(title);
            chart.multibar.stacked(false);

            d3.select(selector)
                .datum(data)
                .transition()
                .duration(500)
                .call(chart);

        nv.utils.windowResize(chart.update);

        return chart;
    });
};

TestsCoco.DataVis.prototype.makeHistogram = function(data, container, title) {

    if(document.getElementById(container) === null) {
        $(this.container).append('<div id='+container+'><svg></svg></div>');
    }
    var selector = '#'+container+' svg';

    nv.addGraph(function() {
        var chart = nv.models.discreteBarChart()
            .x(function(d) { return d.label; })
            .y(function(d) { return d.value; })
            .staggerLabels(true)
            .showValues(true)
            .duration(250);


        chart.yAxis.axisLabel(title);

        d3.select(selector)
            .datum(data)
            .call(chart);

        nv.utils.windowResize(chart.update);
        return chart;
    });
};

/*
 * ScatterGraphs
 *
 */

TestsCoco.DataVis.prototype.dataForScatter_UtileJuste = function(tab_medias) {
    var _this = this;
    return _.mapValues(tab_medias, function(val, key) {
        var sorted_question_obj = _this.sortAndComplete(val);
        return [{
            'key' : key,
            'values' : _.map(sorted_question_obj, function(q_val, q_idx) {
                return {
                    'x' : (q_val.useful + q_val.useless)==0 ? 0 : (q_val.useful - q_val.useless) / (q_val.useful + q_val.useless),
                    'y' : (q_val.right_answer + q_val.wrong_answer)==0 ? 0: (q_val.right_answer - q_val.wrong_answer) / (q_val.right_answer + q_val.wrong_answer),
                    'shape' : 'circle',
                    'question_id' : q_idx
                };
            })
        }];
    });
};

TestsCoco.DataVis.prototype.dataForScatter_UtileJusteByTps = function(tab_medias, infos, keys) {
    var _this = this;
    return _.mapValues(tab_medias, function(med_val, med_id) {
        var sorted_question_obj = _this.sortAndComplete(med_val);
        return keys.map(function(key) {
            return {
                'key' : key,
                'values' : _.map(
                    _.pick(sorted_question_obj, function(q_val, q_idx) {
                        return infos[q_idx] !== undefined;
                    }), function(q_val, q_idx) {
                    var ordonnee;
                    if (key == 'Justesse') {
                        ordonnee = (q_val.right_answer + q_val.wrong_answer) == 0 ? 0: (q_val.right_answer - q_val.wrong_answer) / (q_val.right_answer + q_val.wrong_answer);
                    } else {
                        ordonnee = (q_val.useful + q_val.useless) == 0 ? 0 : (q_val.useful - q_val.useless) / (q_val.useful + q_val.useless);
                    }
                    return {
                        'x':  infos[q_idx].time,
                        'y':  ordonnee,
                        'shape': 'circle'
                    };
                })
            };
        });
    });
};

TestsCoco.DataVis.prototype.dataForScatter_NoteStudent = function(dates, sessionbymedia, properties) {
    var _this = this;
    return _.mapValues(sessionbymedia, function(media_val, media_id) {
        return _.map(properties, function(user_value, user_id) {
            var sorted_tab = _this.sortAndComplete(user_value);
            var values = _.map(
                _.filter(sorted_tab, function(session_val, session_id) {
                    return media_val.indexOf(session_id) > -1;
                }), function(session_val, session_id) {
                    return {
                        'x' : dates[session_id],
                        'y' : (session_val.right_answer * 100) / (session_val.right_answer + session_val.wrong_answer),
                        'shape' : 'circle'
                    };
                });
            var xSerie = _.map(values, function(val) {return val.x.getTime();});
            var ySerie = _.pluck(values, 'y');
            var leastData = _this.leastSquares(xSerie, ySerie);
            return {
                'key' : user_id,
                'values' : values,
                'slope' : leastData[0],
                'intercept' : leastData[1]
            };
        });
    });
};

TestsCoco.DataVis.prototype.dataForScatter_HistoStudent = function(dates, sessionbymedia, properties) {
    var _this = this;
    var ret = {};
    _.each(properties, function(value, index) {
        ret[index] = [];
        _.each(sessionbymedia, function(med_value, med_id) {
            var medias = {};
            medias['key'] = med_id;
            medias['values'] = [];
            var sorted_tab = _this.sortAndComplete(value);
            _.each(sorted_tab, function(session_value, session_idx) {
                if(_.indexOf(session_idx, med_value) != -1) {
                    var point = {};
                    point['x'] = dates[session_idx];
                    point['y'] = (session_value.right_answer *100) / (session_value.right_answer + session_value.wrong_answer);
                    point['shape'] = 'circle';
                    medias['values'].push(point);
                }
            });
            ret[index].push(medias);
        });
    });
    return ret;
};

TestsCoco.DataVis.prototype.makeScatterGraph_Student = function(data, container) {
    if(document.getElementById(container) === null) {
        $(this.container).append('<div id='+container+'><svg></svg></div>');
    }
    var selector = '#'+container+' svg';

    nv.addGraph(function() {
        var chart = nv.models.scatterChart()
            .yDomain([0, 100])
            .showDistX(true)
            .showDistY(true)
            .color(d3.scale.category10().range())
            .duration(300);

        chart.xAxis.axisLabel('Temps');
        chart.yAxis.axisLabel('Notes (%)');
        chart.xAxis.tickFormat(function(d) {
            return d3.time.format('%d/%m/%y')(new Date(d));
        });
        chart.yAxis.tickFormat(d3.format('.02f'));

        d3.select(selector)
            .datum(data)
            .call(chart);

        nv.utils.windowResize(chart.update);

        return chart;
    });

};

TestsCoco.DataVis.prototype.makeScatterGraph_UtileJusteByTps = function(data, mediaInfo, container) {
    if(document.getElementById(container) === null) {
        $(this.container).append('<div id='+container+'><svg></svg></div>');
    }
    var selector = '#'+container+' svg';

    nv.addGraph(function() {
        var chart = nv.models.scatterChart()
            .xDomain([0, mediaInfo.max_time])
            .yDomain([-1, 1])
            .showDistX(true)
            .showDistY(true)
            .color(d3.scale.category10().range())
            .duration(300);

        chart.xAxis.axisLabel('Temps');
        chart.yAxis.axisLabel('');
        chart.xAxis.tickFormat(function(d) {
            return d3.time.format('%X')(new Date(d+ new Date(2015, 7, 22, 0, 0).getTime()));
        });
        chart.yAxis.tickFormat(d3.format('.02f'));


        d3.select(selector)
            .datum(data)
            .call(chart);

        nv.utils.windowResize(chart.update);
        var lineX = d3.select(selector)
                            .append('line')
                            .attr({
                                x1: 75 + chart.xAxis.scale()(0),
                                y1: 30 + chart.yAxis.scale()(0),
                                x2: 75 + chart.xAxis.scale()(mediaInfo.max_time),
                                y2: 30 + chart.yAxis.scale()(0)
                            })
                            .style("stroke", "#000000");

        nv.utils.windowResize(chart.update);nv.utils.windowResize(function() {
            chart.update();
            lineX.attr({
                x1: 75 + chart.xAxis.scale()(0),
                y1: 30 + chart.yAxis.scale()(0),
                x2: 75 + chart.xAxis.scale()(mediaInfo.max_time),
                y2: 30 + chart.yAxis.scale()(0)
            });
        });


        return chart;
    });
};

TestsCoco.DataVis.prototype.makeScatterGraph_UtileJuste = function(data, container) {

    if(document.getElementById(container) === null) {
        $(this.container).append('<div id='+container+'><svg></svg></div>');
    }
    var selector = '#'+container+' svg';
    var visu = this;
    var chart;
    nv.addGraph(function() {
        chart = nv.models.scatterChart()
            .xDomain([-1, 1])
            .yDomain([-1, 1])
            .showXAxis(true)
            .showYAxis(true)
            .color(d3.scale.category10().range())
            .duration(300);

        chart.xAxis.axisLabel('Utilité de la question');
        chart.yAxis.axisLabel('Justesse de la réponse');
        chart.xAxis.tickFormat(d3.format('.02f'));
        chart.yAxis.tickFormat(d3.format('.02f'));
        chart.xAxis.ticks(10);
        chart.yAxis.ticks(10);

        d3.select(selector)
            .datum(data)
            .call(chart);

            var lineX = d3.select(selector)
                            .append('line')
                            .attr({
                                x1: 75 + chart.xAxis.scale()(-1),
                                y1: 30 + chart.yAxis.scale()(0),
                                x2: 75 + chart.xAxis.scale()(1),
                                y2: 30 + chart.yAxis.scale()(0)
                            })
                            .style("stroke", "#000000");
            var lineY = d3.select(selector)
                            .append('line')
                            .attr({
                                x1: 75 + chart.xAxis.scale()(0),
                                y1: 30 + chart.yAxis.scale()(-1),
                                x2: 75 + chart.xAxis.scale()(0),
                                y2: 30 + chart.yAxis.scale()(1)
                            })
                            .style("stroke", "#000000");

        nv.utils.windowResize(chart.update);
        nv.utils.windowResize(function() {
            chart.update();
            lineX.attr({
                x1: 75 + chart.xAxis.scale()(-1),
                y1: 30 + chart.yAxis.scale()(0),
                x2: 75 + chart.xAxis.scale()(1),
                y2: 30 + chart.yAxis.scale()(0)
            });
            lineY.attr({
                x1: 75 + chart.xAxis.scale()(0),
                y1: 30 + chart.yAxis.scale()(-1),
                x2: 75 + chart.xAxis.scale()(0),
                y2: 30 + chart.yAxis.scale()(1)
            });
        });
        return chart;
    },
                function() {
                    chart.scatter.dispatch.on('elementClick', function(e) {
                        var id_question = e.point.question_id;
                        visu.generateAnswerDetails('detailsQuestion', id_question);
                    });
                });
};

/*
 * Scatter Visu Algo
 *
 */

 TestsCoco.DataVis.prototype.dataForScatter_VisuAlgo = function(sessionByMedia, properties, infos, sessionDates) {
     var _this = this,
         colors = {  'utile': 'green',
                     'inutile': 'red',
                     'neutre': 'grey',
                     'pas voté': 'black'
                  };

     return _.mapValues(sessionByMedia, function(med_val, med_id) {
         return _.map(colors,  function (category, cle) {
             var temp=[];
             var n = _.size(med_val);
            med_val.forEach(function(s_val) {
                var sorted_question_obj = _this.sortAndComplete(properties[s_val]);
                _.each(sorted_question_obj, function(q_val, q_idx) {
                    var utility = (q_val.useful + q_val.useless) == 0 ? 0 : (q_val.useful - q_val.useless) / (q_val.useful + q_val.useless);
                    var key = 'inutile';
                    if (q_val.skipped_vote) {
                        key = 'pas voté';
                    } else if (utility == 0) {
                        key = 'neutre';
                    } else if (utility > 0) {
                        key = 'utile';
                    };

                    temp.push({
                        'x' : infos[q_idx] != undefined ? infos[q_idx].time : 0,
                        'y' : n,
                        'key' : key,
                        'shape' : 'circle' });
                });
                n--;
            });
            return {
                key: cle,
                color: category,
                values: temp.filter( function (p) { return p.key == cle; }) 
            };
        });
    });
 };

TestsCoco.DataVis.prototype.makeScatterGraph_VisuAlgo = function (data, size, mediaInfo, media) {
    if(document.getElementById(media) === null) {
        var str = '<div class="panel panel-default">'
                        +'<div class="panel-heading">'
                            +'<i class="fa fa-bar-chart-o fa-fw"></i> Visualisation de l\'algorithme sur la video '+media
                        +'</div>'
                        +'<div class="panel-body">'
                            +'<div id="graph_'+media+'" align="center"><svg></svg></div>'
                        +'</div>'
                    +'</div>';
        $('.analytics').append(str);
    }
    var selector = '#graph_'+media+' svg';

    nv.addGraph(function() {
        var chart = nv.models.scatterChart()
            .xDomain([0, mediaInfo.max_time])
            .yDomain([(size+2), 0])
            .showDistX(true)
            .showDistY(true)
            .color(d3.scale.category10().range())
            .duration(300);

        chart.xAxis.axisLabel('Temps Video');
        chart.yAxis.axisLabel('Tirage');
        chart.xAxis.tickFormat(function(d) {
            return d3.time.format('%X')(new Date(d+ new Date(2015, 7, 22, 0, 0).getTime()));
        });



        d3.select(selector)
            .datum(data)
            .call(chart);

        nv.utils.windowResize(chart.update);
        return chart;
    });
};

/*
 * LineGraphs
 *
 */

TestsCoco.DataVis.prototype.dataForLineGraph = function(tab_date, tab_user) {
    var _this = this;
    return _.mapValues(tab_user, function(user) {
        return [
            {
                'key' : 'Note',
                'values' : _(_this.sortAndComplete(user)).map(function(session_value, session_index) {
                    var date = tab_date[session_index];
                    var moyenne = (session_value.right_answer * 100) / (session_value.right_answer + session_value.wrong_answer);
                    if (date !== undefined && !isNaN(moyenne)) {
                        return [ date, moyenne ];
                    } else {
                        return undefined;
                    }
                }).filter(function (v) { return v !== undefined; }).value()
            }
        ];
    });
};

TestsCoco.DataVis.prototype.makeLineGraph = function(data, container) {

    if(document.getElementById(container) === null) {
        $(this.container).append('<div id='+container+'><svg></svg></div>');
    }
    var selector = '#'+container+' svg';

    nv.addGraph(function() {
        var chart = nv.models.lineChart()
            .useInteractiveGuideline(false)
            .x(function(d) { return d[0]; })
            .y(function(d) { return d[1]; })
            .color(d3.scale.category10().range())
            .duration(300);

        chart.xAxis.axisLabel('Date');
        chart.yAxis.axisLabel('Note');
        chart.xAxis.tickFormat(function(d) {
            return d3.time.format('%d/%m/%y')(new Date(d));
        });

        chart.yAxis.tickFormat(d3.format('1'));



        d3.select(selector)
            .datum(data)
            .call(chart);

        nv.utils.windowResize(chart.update);

        return chart;
    });
};

TestsCoco.DataVis.prototype.makeSparkLine = function(data, container) {
    var users = _.keys(data);
    var _this = this;
    var str = '<tr><th id="smallColumn">Nom</th><th id="bigColumn">Courbe de progression</th><th id="smallColumn">Moyenne de l\'élève (%)</th><th id="smallColumn">Indice de progression</th></tr>';
    users.forEach(function(elem) {
        str+='<tr><td class="smallColumn">'+elem+'</td><td><svg id="chart_'+elem+'" class="sparkline"></svg></td><td class="smallColumn" id="average_'+elem+'"></td><td class="smallColumn" id="progression_'+elem+'"></td>/tr>';
    });
    $('#'+container).append(str);

    users.forEach(function(user) {
        var chart_selector = '#chart_'+user,
            average_selector = '#average_'+user,
            progression_selector = '#progression_'+user;

        nv.addGraph(function() {
            var chart = nv.models.sparklinePlus();
            chart.margin({left: 0})
                .x(function(d) { return d[0]; })
                .y(function(d) { return d[1]; })
                .showLastValue(true)
                .xTickFormat(function(d) {
                    return d3.time.format('%d/%m/%y')(new Date(d));
                });

            d3.select(chart_selector)
                    .datum(data[user][0].values)
                    .call(chart);

            return chart;
        });

        var notes = [];
        var dates = [];
        data[user][0].values.forEach(function(note) {
            notes.push(note[1]);
            dates.push(note[0].getTime());
        });
        var average = _.round(_.sum(notes)/notes.length, 2);
        $(average_selector).append(average);
        var prog = _this.leastSquares(dates, notes)[0] > 0 ? 'bien' : 'pas bien';
        $(progression_selector).append(prog);
    });
};

/*
 * BulletCharts
 *
 */

TestsCoco.DataVis.prototype.dataForBullet = function (userAverage, generalAverage) {

    return _.mapValues(userAverage, function(user) {
        return _.map(user, function(media_value, media_index) {
            return {
                'title' : "Moyenne",
                'subtitle' : media_index,
                'ranges' :  [0, 50, 100],
                'measures' : [media_value],
                'markers' : [generalAverage[media_index]],
                'markerLabels' : ['Moyenne générale'],
                'measureLabels' : ['Moyenne étudiant']
            };
        });
    });
};

TestsCoco.DataVis.prototype.makeBulletChart = function(data, container) {
    var width = 760,
        height = 80,
        margin = {top: 5, right: 40, bottom: 25, left: 120};

    var chart = nv.models.bulletChart()
            .width(width - margin.right - margin.left)
            .height(height - margin.top - margin.bottom);

    var vis = d3.select("#"+container).selectAll("svg")
        .data(data)
        .enter().append("svg")
        .attr("class", "bullet nvd3")
        .attr("width", width)
        .attr("height", height);

    vis.transition().duration(1000).call(chart);

    return vis;
};

/**
 * Get all the data needed to make all the graphs
 *
 * @method     getAllData
 * @param      {Object}  questions  Set of questions
 * @param      {Object}  answers    Set of answers
 */
TestsCoco.DataVis.prototype.getAllData = function (questions, answers) {
    this.annotations = questions.annotations;

    this.medias = _.groupBy(this.annotations, 'media');

    this.sessions = _.groupBy(answers, 'session');

    this.properties_count = _.countBy(answers, 'property');

    this.propertiesByQuestion = this.getPropertiesByKey(answers, 'subject', 'property');
    this.propertiesBySession = this.getPropertiesByKey(answers, 'session', 'property');

    this.userBySession = this.getPropertiesByKey(answers, 'session', 'useruuid');
    this.userByQuestion = this.getPropertiesByKey(answers, 'subject', 'useruuid');

    this.propertiesByUserByQuestion = this.aggregate(answers, 'subject', 'useruuid', 'property');
    this.propertiesByUserBySession = this.aggregate(answers, 'session', 'useruuid', 'property');

    this.propertiesByQuestionByUser = this.aggregate(answers, 'useruuid', 'subject', 'property');
    this.propertiesBySessionByUser = this.aggregate(answers, 'useruuid', 'session', 'property');

    this.propertiesByQuestionBySession = this.aggregate(answers, 'session', 'subject', 'property');

    this.NbAnswerByQuestion = this.getNbAnswerByQuestion(answers);

    this.session_date = this.getSessionDate(answers);

    this.info_questions = this.getInfoQuestions(this.annotations);

    this.propertiesByMedia = this.getPropertiesByMedia();
    this.propertiesByQuestionByMedia = this.getPropertiesByQuestionByMedia();

    this.mediaBySession = this.getMediaBySession();
    this.sessionByMedia = this.getSessionByMedia();

    // Data For Student
    this.data_Histo_answer = this.dataForHisto_AnsVote(['right_answer', 'wrong_answer', 'skipped_answer'], this.propertiesByMedia, this.propertiesBySessionByUser, this.mediaBySession);
    this.data_Histo_vote = this.dataForHisto_AnsVote(['useful', 'useless', 'skipped_vote'], this.propertiesByMedia, this.propertiesBySessionByUser, this.mediaBySession);
    this.data_Bullet = this.dataForBullet(this.getUsersAverage(this.propertiesBySessionByUser, this.sessionByMedia), this.getGeneralAverage(this.medias));
    this.data_Scatter_HistoStudent = this.dataForScatter_HistoStudent(this.session_date, this.sessionByMedia, this.propertiesBySessionByUser);

    // Data For Teacher
    this.data_Line = this.dataForLineGraph(this.session_date, this.propertiesBySessionByUser);
    this.data_Scatter_UtileJuste = this.dataForScatter_UtileJuste(this.propertiesByQuestionByMedia);
    this.data_Scatter_UtileJusteByTps = this.dataForScatter_UtileJusteByTps(this.propertiesByQuestionByMedia, this.info_questions, ['Justesse', 'Utilité']);
    this.data_Scatter_NoteStudent = this.dataForScatter_NoteStudent(this.session_date, this.sessionByMedia, this.propertiesBySessionByUser);

    // Data For Questions
    this.data_Histo_answer_detail = this.dataForHisto_AnswerDetail(this.NbAnswerByQuestion, this.info_questions);

    // Data For VisuAlgo
    this.data_Scatter_VisuAlgo = this.dataForScatter_VisuAlgo(this.sessionByMedia, this.propertiesByQuestionBySession, this.info_questions, this.session_date);
};

/**
 * Generates the graphs needed for the student dashboard
 *
 * @method     generateGraphStudent
 * @param      {<type>}  username
 * @param      {<type>}  session_number
 */
TestsCoco.DataVis.prototype.generateGraphStudent = function(useruuid, session_number) {
    this.makeHistogram_AnsVote(this.data_Histo_answer[useruuid][session_number], 'bonneMauvaiseSkip', 'Pourcentage de réponses');

    this.makeHistogram_AnsVote(this.data_Histo_vote[useruuid][session_number], 'utilePasUtile', 'Pourcentage de votes');

    this.makeBulletChart(this.data_Bullet[useruuid], 'bulletChartAllStudents');
};

/**
 * Generates the graphs needed for the teacher dashboard
 *
 * @method     generateGraphTeacher
 * @param      {<type>}  media_id
 */
TestsCoco.DataVis.prototype.generateGraphTeacher = function(media_id){

    this.makeScatterGraph_UtileJuste(this.data_Scatter_UtileJuste[media_id],'repUtile');

    this.makeSparkLine(this.data_Line,'table_spark');

    this.makeScatterGraph_Student(this.data_Scatter_HistoStudent[useruuid], 'histoStudentAllVideos');
};

TestsCoco.DataVis.prototype.generateGraphTeacher = function(media_id) {

    this.makeScatterGraph_UtileJuste(this.data_Scatter_UtileJuste[media_id], 'repUtile');

    this.makeSparkLine(this.data_Line, 'table_spark');

    this.makeScatterGraph_UtileJusteByTps(this.data_Scatter_UtileJusteByTps[media_id], this.getMediaInfo(media_id), 'repUtileTps');

    this.makeScatterGraph_Student(this.data_Scatter_NoteStudent[media_id], 'histoAllStudents');
};

/**
 * Generates the graphs for the answers details
 *
 * @method     generateAnswerDetails
 * @param      {string}  container    HTML id of the container where to place the answers details
 * @param      {string}  question_id
 */
TestsCoco.DataVis.prototype.generateAnswerDetails = function (container, question_id) {
    $('#'+container).empty();

    var q_info = this.info_questions[question_id];
    var q_prop = this.sortAndComplete(this.propertiesByQuestion)[question_id];
    var useful = (q_prop.useful + q_prop.useless) == 0 ? 0 : q_prop.useful * 100 / (q_prop.useful + q_prop.useless);
    var useless = (q_prop.useful + q_prop.useless) == 0 ? 0 : q_prop.useless * 100 / (q_prop.useful + q_prop.useless);

    var str_detail = "";
    if (q_info) {
        str_detail = '<div id="questionContent" ><b>Question:</b>' + q_info.enonce + '<br><br><ol>';
        q_info.answers.forEach(function(answer) {
            str_detail+='<li>' + answer + '</li>';
        });
        str_detail += '</ol></div>';
    } else {
        str_detail = '<div id="questionContent"><b>Unknown question</b></div>';
    }
    str_detail += '<div id="voteParRep"><h3 id="utPUt">Utile: '+_.round(useful, 2)+'% - Pas utile: '+_.round(useless, 2)+'%</h3><svg></svg></div>';

    $('#'+container).append(str_detail);

    this.makeHistogram(this.data_Histo_answer_detail[question_id], 'voteParRep', 'Nombre de réponses');
};

/**
 * Generates the graphs for the visualisation of the algorithm
 *
 * @method     generateGraphVisuAlgo
 */
TestsCoco.DataVis.prototype.generateGraphVisuAlgo = function(){
    var _this = this;
    _.each(this.medias, function(med_val, med_id) {
        var size = _.size(_this.sessionByMedia[med_id]);
        _this.makeScatterGraph_VisuAlgo(_this.data_Scatter_VisuAlgo[med_id], size, _this.getMediaInfo(med_id), med_id);
    });
};

/**
 * Main function of the Datavis class, only for tests purpose
 *
 * @method     main
 * @param      {Object}  questions  Set of questions
 * @param      {Object}  answers    Set of answers
 * @param      {string}  type       Tells wich type of visualisation to generate
 */
TestsCoco.DataVis.prototype.main = function(questions, answers, type) {

    this.getAllData(questions, answers);

    if(type=='student') {
        this.generateGraphStudent('Alfred', '5fc69b16-dcc6-4599-b82d-06404576d4dd');
    }
    else if(type=='teacher') {
        this.generateGraphTeacher('m20131010');
    }

};
